{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udccb Notes Progress Tracker","text":"<p>A running task list of topics I need to finish documenting in my notes. I\u2019ll check them off here as I complete them.</p>"},{"location":"#backend-deployment","title":"\ud83d\ude80 Backend &amp; Deployment","text":"<ul> <li> Getting Started  </li> <li> HTTP Concepts  </li> <li> FastAPI and Pydantic Basics  </li> <li> FastAPI Query Validation and Dynamic Path Validation  </li> <li> Service Layer and Dependency Injection  </li> <li> Introduction into Testing </li> <li> Introduction to CI/CD</li> </ul>"},{"location":"#frontend-general-topics","title":"\ud83d\udcbb Frontend &amp; General Topics","text":"<ul> <li> TypeScript and Event Driven Programming  </li> <li> HTML and CSS  </li> <li> Angular Introduction  </li> <li> Angular Routing  </li> <li> RxJS Observables  </li> <li> Introduction to SQL  </li> <li> Angular Widgets  </li> <li> Authentication and Authorization  </li> <li> Secrets, Environment Variables, and OpenAI  </li> </ul>"},{"location":"#gigmatcher-codebase","title":"\u26a1 GIGMatcher Codebase","text":"<ul> <li> Overview of how PLINKER data is loaded</li> <li> How make_plinker_split_parquet.py works</li> <li> How make_plinder_data_dir.py works</li> <li> How preprocess_plinder_data.py works</li> <li> How pregenerate_gigs.py works</li> </ul>"},{"location":"gigmatcher/dataloading/","title":"Overview of How Plinker Data is Prepped for Training","text":"<p>The entire process for how PLINDER data is prepped and transformed into the dataset used for training is managed by scripts in the <code>gigmatcher/scripts/data_prep/</code> directory</p>"},{"location":"gigmatcher/dataloading/#1-create-data-splits-make_plinder_split_parquetpy","title":"1. Create Data Splits (<code>make_plinder_split_parquet.py</code>)","text":"<p>This is the first step, which defines the train, validation, and test sets.</p> <ol> <li> <p>Query PLINDER: It queries the full PLINDER database to get a list of all protein-ligand systems.</p> </li> <li> <p>Filter Entries: It filters this list, removing entries with fewer than a minimum number of interacting residues (e.g., 2).</p> </li> <li> <p>Get Clusters: It loads PLINDER's pre-computed cluster dataframes (<code>val_cluster_df</code>, <code>test_cluster_df</code>) to assign a cluster label to each system. This ensures that structurally similar proteins are kept in the same split.</p> </li> <li> <p>Remove Benchmarks: It has options to identify systems related to common benchmarks (like <code>remove_matcher_benchmark</code>) and move them from the training set to the validation set to prevent data leakage and ensure fair evaluation.</p> </li> <li> <p>Output: It saves separate <code>_train.pq</code>, <code>_val.pq</code>, and <code>_test.pq</code> parquet files (and a <code>.json</code> file) that list the <code>system_ids</code> and cluster information for each split.</p> </li> </ol>"},{"location":"gigmatcher/dataloading/#2-create-raw-data-directories-make_plinder_data_dirpy","title":"2. Create Raw Data Directories (<code>make_plinder_data_dir.py</code>)","text":"<p>This script transforms the parquet files (lists of systems) into the raw file structure needed for processing.</p> <ol> <li> <p>Read Splits: It reads one of the parquet files from Step 1 (e.g., <code>plinder_splits_train_pq.gz</code>).</p> </li> <li> <p>Create Folders: For each <code>system_id</code> in the file, it creates a subdirectory (e.g., <code>/path/to/plinder_train_raw/&lt;system_id&gt;/</code>).</p> </li> <li> <p>Copy/Convert Files:</p> <ul> <li>It copies the system's receptor PDB file from the PLINDER database into its new folder as <code>&lt;system_id&gt;_protein.pdb</code>.</li> <li>It finds all associated ligand <code>.sdf</code> files for that system, combines them, and converts them into a single <code>&lt;system_id&gt;_ligand.mol2</code> file using <code>obabel</code>.</li> </ul> </li> </ol>"},{"location":"gigmatcher/dataloading/#3-preprocess-raw-data-preprocess_plinder_datapy","title":"3. Preprocess Raw Data (<code>preprocess_plinder_data.py</code>)","text":"<p>This is the main transformation step. It takes the raw <code>_protein.pdb</code> and <code>_ligand.mol2</code> files and generates the final training data.</p> <ol> <li> <p>Combine Protein &amp; Ligand: It first combines the <code>&lt;system_id&gt;_protein.pdb</code> and <code>&lt;system_id&gt;_ligand.mol2</code> files into a single <code>_protein_ligand.pdb</code> file.</p> </li> <li> <p>Load &amp; Idealize: The script loads this combined PDB into a Protein object. It then idealizes the protein's sidechains by calculating their chi angles and rebuilding them from standard bond lengths/angles. This ensures a clean, standardized geometry.</p> </li> <li> <p>Run Reduce: It runs the Reduce tool on the idealized protein-ligand structure. This adds and optimizes hydrogen atoms. It uses a custom connectivity database (<code>_reduce_conect.db</code>) generated from the <code>.mol2</code> file to correctly handle the ligand.</p> </li> <li> <p>Extract GIGs:</p> <ul> <li>All Components: It scans the final, reduced protein and extracts all possible GIG components (all \"NH\", \"CO\", \"OH\", \"COO\", etc. interacting pairs) and saves them as <code>&lt;system_id&gt;_gig-comps.npz</code>. This file represents the entire \"GIG library\" available in that one protein.</li> <li>Ligand GIG: It separately analyzes the protein-ligand interface and extracts the specific GIG representing the functional site (i.e., the components interacting with the ligand). This is saved as <code>&lt;system_id&gt;_ligand-gig.npz</code>.</li> </ul> </li> <li> <p>Save Processed Protein: Finally, it saves the processed protein (with idealized sidechains and added hydrogens) as <code>&lt;system_id&gt;_protein.npz</code>, which stores its atomic coordinates, masks, and sequence information in NumPy arrays.</p> </li> </ol>"},{"location":"gigmatcher/dataloading/#4-optional-pre-generate-gigs-pregenerate_gigspy","title":"4. (Optional) Pre-generate GIGs (<code>pregenerate_gigs.py</code>)","text":"<p>This step is for efficiency. Instead of sampling random GIGs from <code>_gig-comps.npz</code> during training, this script does it ahead of time.</p> <ol> <li> <p>Load Data: It loads the <code>_gig-comps.npz</code> (all components) and <code>_protein.npz</code> files.</p> </li> <li> <p>Sample GIGs: It generates many (e.g., 250) random GIGs for the protein by sampling from its full component set, using various filters like max distance and component type biases (e.g., centrality, amino acid type).</p> </li> <li> <p>Output: It saves an array of the indices for these pre-sampled GIGs into a <code>&lt;system_id&gt;_gig-comp-indices.npy</code> file.</p> </li> </ol> <p>At the end of this pipeline, a single PLINDER system is transformed into a set of <code>.npz</code> and <code>.npy</code> files that contain the processed protein scaffold, its full component library, its specific ligand-binding GIG, and (optionally) a list of pre-sampled GIGs for training.</p>"},{"location":"gigmatcher/dataloading/#understanding-make_plpinder_split_parquetpy","title":"Understanding <code>make_plpinder_split_parquet.py</code>","text":"<p>The <code>main</code> function's job is to query the entire PLINDER database, clean and filter all the protein-ligand systems, and then carefully divide them into train, validation, and test sets. </p> <p>Its main goal is to prevent data leakage, which means ensuring that proteins in the training set are not structurally similar to proteins in the validation or test sets. It does this by using pre-computed \"clusters\" (groups of similar proteins).</p> <ol> <li> <p>Gets the start time to track how long the main functions runs for <pre><code>def main(\n    outfile_prefix: str, \n    use_gz: bool, \n    min_interacting_res: int, \n    remove_matcher_benchmark: bool, \n    remove_rfd2_benchmark: bool\n) -&gt; None:\n    t0 = time.time()\n\n    ### Rest of the code...\n\n    print(f'Saved final datasets to {outfiles} in {time.time() - t0:.3f} sec')\n\n    ### More code...\n</code></pre></p> </li> <li> <p>Load all data by calling <code>load_full_plinder_df()</code>. This function queries the PLINDER database and loads all protein-ligand systems into a giant pandas DataFrame. It filters this list, keeping only systems that have at least <code>min_interacting_res</code> (e.g., 2) residues interacting with the ligand. <pre><code># Read full dataset with specific columns\n    cols_of_interest = [\n        \"system_id\", \n        \"entry_pdb_id\", \n        \"ligand_ccd_code\", \n        \"ligand_plip_type\", \n        \"ligand_interacting_residues\", \n        \"ligand_interactions\"\n    ]\n    full_df = load_full_plinder_df(cols_of_interest, min_interacting_res)\n</code></pre></p> <p>load_full_plinder_df()</p> <p><pre><code>def load_full_plinder_df(cols: list[str], min_interacting_res: int, drop_duplicates: bool = True) -&gt; pd.DataFrame:\n    # Read full dataset with specific columns\n    full_df = query_index(columns=cols, splits=[\"*\"])\n\n    # Filter out entries with &lt; min_interacting_res interacting residues\n    entry_mask = [len(row[1]['ligand_interacting_residues']) &gt;= min_interacting_res for row in full_df.iterrows()]\n    if drop_duplicates:\n        return full_df[entry_mask].drop_duplicates(\"system_id\")\n    else:\n        return full_df[entry_mask]\n</code></pre> This function's purpose is to query the main PLINDER database and then clean that data based on two criteria: the number of interacting residues and whether to remove duplicates.</p> <ul> <li><code>drop_duplicates: bool = True</code>: A boolean (True/False) flag. If it's <code>True</code>, the function will remove duplicate entries. It's set to <code>True</code> by default.</li> </ul> </li> </ol>"},{"location":"gigmatcher/dataloading/#1-first-the-function-reads-the-database-and-makes-a-dataframe","title":"1. First the function reads the database and makes a <code>dataframe</code>","text":"<pre><code>full_df = query_index(columns=cols, splits=[\"*\"])\n</code></pre> <ul> <li><code>query_index</code> function is imported from PLINDER</li> <li> <p><code>columns=cols</code>: It tells the query to only fetch the columns specified in the cols list that was passed into the function.</p> </li> <li> <p><code>splits=[\"*\"]</code>: This is a wildcard, telling the query to fetch data from all splits (train, val, test, etc.) in the database.</p> </li> </ul>"},{"location":"gigmatcher/dataloading/#2-second-the-function-filters-entries","title":"2. Second the function filters entries","text":"<pre><code>entry_mask = [len(row[1]['ligand_interacting_residues']) &gt;= min_interacting_res for row in full_df.iterrows()]\n</code></pre> <ul> <li>This line builds a \"mask,\" which is a list of <code>True</code> and <code>False</code> values</li> <li>It loops through every row in the dataframe and it gets the value from the <code>ligand_interacting_residues</code> column and calculates its length (i.e., how many interacting residues there are).</li> <li>It checks if that number is greater than or equal to the <code>min_interacting_res</code> value and the entry_mask will mark which rows to keep(<code>True</code>) and which to discard (<code>False</code>).</li> </ul>"},{"location":"gigmatcher/dataloading/#3-return-the-cleaned-data","title":"3. Return the cleaned data","text":"<pre><code>if drop_duplicates:\n    return full_df[entry_mask].drop_duplicates(\"system_id\")\nelse:\n    return full_df[entry_mask]\n</code></pre> <ul> <li>returns the cleaned data depending on the <code>drop_duplicates</code> flag</li> </ul>"},{"location":"swe/cicd/","title":"Introduction to CI/CD","text":"<p>Modern software development moves fast. Teams need to deliver features quickly, fix bugs rapidly, and maintain high-quality code\u2014all while ensuring deployments are smooth and reliable. This is where CI/CD comes in.</p> <ul> <li>Continuous Integration (CI) automates the process of running tests on new code changes whenever they are pushed to a central repository. This ensures that issues are caught early and developers get fast feedback.</li> <li>Continuous Deployment (CD) takes things a step further by automating the deployment of every successfully tested change directly into production\u2014without manual intervention. This allows teams to ship updates multiple times a day with confidence.</li> </ul> <p>Continuous Delivery vs. Continuous Deployment</p> <p>Continuous Delivery ensures that every tested change is ready for deployment but still requires a manual approval step before going live. Continuous Deployment, on the other hand, removes this manual step and automatically pushes changes to production once they pass all verification checks.</p> <p>In this tutorial, we\u2019re focusing on Continuous Deployment, where code moves to production immediately after passing CI tests.</p>"},{"location":"swe/cicd/#why-cicd-matters","title":"Why CI/CD Matters","text":"<p>Manually running tests and deploying software can be slow, inconsistent, and prone to human error. CI/CD automates these critical steps, leading to:</p> <ul> <li>Faster development cycles \u2013 Developers can push changes more frequently without worrying about breaking things.</li> <li>Less anxiety \u2013 Automated testing and deployment remove the guesswork, making releases predictable and repeatable.</li> <li>Higher confidence \u2013 If every change is tested and verified before it reaches production, teams can move forward with fewer worries about stability.</li> </ul> <p>By embracing automation, teams shift from a culture of hesitation and uncertainty to one of confidence and speed.</p>"},{"location":"swe/cicd/#cicd-pipeline-tutorial-with-the-rps-game","title":"CI/CD Pipeline Tutorial with the RPS Game","text":"<p>In this tutorial, you\u2019ll configure a full CI/CD pipeline for our Rock, Paper, Scissors (RPS) application. We'll use GitHub Actions for CI and a Kubernetes-based platform (OKD) for CD.</p>"},{"location":"swe/cicd/#the-application-code","title":"The Application Code","text":"<p>We will use the same Rock, Paper, Scissors application we built in the \"Service Layer and Dependency Injection\" and \"Introduction to Testing\" sections. The code for <code>models.py</code>, <code>services.py</code>, and <code>main.py</code> will be the same.</p>"},{"location":"swe/cicd/#dependencies-requirementstxt","title":"Dependencies (<code>requirements.txt</code>)","text":"<p>First, ensure you have a <code>requirements.txt</code> file that includes all the necessary packages for the application and for testing.</p> requirements.txt<pre><code>fastapi[standard]~=0.115.7\npytest~=8.3.4\n</code></pre>"},{"location":"swe/cicd/#the-tests","title":"The Tests","text":"<p>Our CI pipeline will run the tests we wrote previously. These include unit tests for the service and integration tests for our API endpoints. Having these tests is crucial for an effective CI process.</p>"},{"location":"swe/cicd/#part-1-continuous-integration-ci-with-github-actions","title":"Part 1: Continuous Integration (CI) with GitHub Actions","text":"<p>Continuous Integration is controlled by a GitHub Action workflow file. This file tells GitHub what to do whenever code is pushed to the repository.</p>"},{"location":"swe/cicd/#the-workflow-file-githubworkflowstestyml","title":"The Workflow File (<code>.github/workflows/test.yml</code>)","text":"<p>Create a file at this path in your repository. This workflow will check out your code, install dependencies, and run <code>pytest</code>.</p> .github/workflows/test.yml<pre><code>name: Run Python Tests\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.x\"\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n\n      - name: Test with pytest (CI)\n        run: pytest\n\n      - name: Deploy to production (CD)\n        if: success()\n        run: |\n          curl -X POST \"${{ secrets.WEBHOOK_URL }}\"\n</code></pre> What does the <code>curl</code> command do? <p>The <code>Deploy to production (CD)</code> step is the bridge between your CI and CD systems. <code>yaml run: | curl -X POST \"${{ secrets.WEBHOOK_URL }}\"</code></p> <ul> <li><code>curl</code>: This is a command-line tool for making web requests.</li> <li><code>-X POST</code>: This specifies that we are sending an HTTP <code>POST</code> request. A <code>POST</code> request is used here because we are asking the server (OKD) to take an action\u2014in this case, start a new deployment.</li> <li><code>\"${{ secrets.WEBHOOK_URL }}\"</code>: This is the most important part.</li> <li><code>secrets.WEBHOOK_URL</code>: This securely accesses the secret value you stored in your GitHub repository's settings. You should never paste secret URLs or tokens directly into your code.</li> <li><code>${{ ... }}</code>: This is the syntax GitHub Actions uses to substitute the value of a variable or secret into the workflow.</li> </ul> <p>In short, this command sends a secure notification to your deployment server (OKD), telling it that the tests have passed and it's time to start building and deploying the new version of the application.</p> <p>Once you commit and push this file, go to the \"Actions\" tab in your GitHub repository. You should see the workflow running. If all tests pass, you'll see a green checkmark! This confirms that your CI pipeline is working. \u2705</p>"},{"location":"swe/cicd/#part-2-continuous-deployment-cd-with-okd","title":"Part 2: Continuous Deployment (CD) with OKD","text":"<p>Now that our tests pass, we'll set up a pipeline to automatically deploy the application to a production environment (OKD).</p>"},{"location":"swe/cicd/#1-the-dockerfile","title":"1. The Dockerfile","text":"<p>To deploy our app, we need to package it into a container. A <code>Dockerfile</code> provides the instructions to do this.</p> Dockerfile<pre><code># Use the official Python 3.13 image as the base image.\nFROM python:3.13\n\n# Set the working directory in the container.\nWORKDIR /app\n\n# Copy requirements file to the container.\nCOPY ./requirements.txt /app/requirements.txt\n\n# Install the Python dependencies.\nRUN pip install --upgrade pip &amp;&amp; \\\n    pip install -r requirements.txt\n\n# Copy the rest of the application code.\nCOPY . /app\n\n# Expose port 8080 which uvicorn will run on.\nEXPOSE 8080\n\n# Command to run FastAPI in production mode using uvicorn.\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"]\n</code></pre> Breaking Down the Dockerfile <p>Each line in a Dockerfile is a specific instruction for building your application's container image.</p> <ul> <li><code>FROM python:3.13</code>: This sets the foundation. It tells Docker to start with an official base image that already has Python 3.13 installed.</li> <li><code>WORKDIR /app</code>: This sets the default working directory inside the container to <code>/app</code>. All subsequent commands (<code>COPY</code>, <code>RUN</code>, <code>CMD</code>) will be executed from this directory.</li> <li><code>COPY ./requirements.txt /app/requirements.txt</code>: This copies just the <code>requirements.txt</code> file from your local project into the container. We do this first so Docker can cache the installed dependencies. If your code changes but <code>requirements.txt</code> doesn't, Docker can skip reinstalling everything, making builds faster.</li> <li><code>RUN pip install ...</code>: This command executes inside the container. It installs the Python packages listed in <code>requirements.txt</code>.</li> <li><code>COPY . /app</code>: This copies the rest of your application code (like <code>main.py</code>, <code>services.py</code>, etc.) into the <code>/app</code> directory inside the container.</li> <li><code>EXPOSE 8080</code>: This is informational. It tells Docker that the application inside the container will listen on port 8080. It doesn't actually open the port, but serves as documentation for the person running the container.</li> <li><code>CMD [\"uvicorn\", ...]</code>: This specifies the default command to run when the container starts. It starts the <code>uvicorn</code> server to run your FastAPI application, making it accessible on all network interfaces (<code>--host 0.0.0.0</code>) on port 8080 (<code>--port 8080</code>).</li> </ul>"},{"location":"swe/cicd/#2-generate-a-github-personal-access-token-pat","title":"2. Generate a GitHub Personal Access Token (PAT)","text":"<p>Your deployment platform (OKD) needs permission to pull your code from your private GitHub repository. To grant this, you'll create a Personal Access Token.</p> <ol> <li>In GitHub, go to Settings &gt; Developer settings &gt; Personal access tokens &gt; Tokens (classic).</li> <li>Click Generate new token (classic).</li> <li>Give it a descriptive name (e.g., \"OKD-Deployment-Key\").</li> <li>Select the <code>repo</code> scope.</li> <li>Click Generate token and copy the token immediately. You won't be able to see it again.</li> </ol>"},{"location":"swe/cicd/#3-configure-the-deployment-environment","title":"3. Configure the Deployment Environment","text":"<p>(These steps assume you have access to an OKD cluster and have the <code>oc</code> command-line tool installed).</p> For UNC Students <p>Setting up deployment takes some more effort because we need to stand up a production cloud environment. The production environment will be UNC Cloud Apps' \"OKD\" cluster.</p> <p>You need to be connected to Eduroam, or connected to UNC VPN (instructions here), in order to successfully use OKD. If you are on a home network, UNC guest, or other network, be sure to connect via VPN.</p> <p>Login to OKD by going to: https://console.apps.unc.edu</p> <p>(If your login does not succeed, it's likely because you did not previously register for Cloud Apps. You can do so by going to https://cloudapps.unc.edu/ and following the Sign Up steps. It can take up to 15 minutes following Sign Up for the OKD link above to work correctly. In the interim, feel free to follow along with your neighbor.)</p> <p>Once logged in you should see OKD in the upper-left corner. If you see \"Red Hat\", be sure you opened the link above.</p> <p>Now that you are logged in, go to the upper-right corner and click your <code>ONYEN</code> and go to the <code>\"Copy Login Command\"</code> link. Click <code>Display Token</code>. In this, copy the command in the first text box. Paste it into your dev container's terminal (which has the oc command-line application for interfacing with a Red Hat Open-Shift Kubernetes cluster installed).</p> <p>Before proceeding, switch to your personal OKD project using your ONYEN. For example, if your ONYEN is \"jdoe\", run:</p> <pre><code>oc project comp590-140-25sp-jdoe\n</code></pre> <p>If the above command fails, restart the steps above! The following will not work until you are able to access your project via oc.</p> <ol> <li>Log in to OKD and select your project.</li> <li>Create a secret to store your GitHub credentials. Replace <code>&lt;your-github-username&gt;</code> and <code>&lt;your-github-pat&gt;</code> with your actual username and the token you just generated.     <pre><code># Choose a name for your secret, e.g., \"github-repo-secret\"\noc create secret generic &lt;your-secret-name&gt; \\\n    --from-literal=username=&lt;your-github-username&gt; \\\n    --from-literal=password=&lt;your-github-pat&gt; \\\n    --type=kubernetes.io/basic-auth\n</code></pre></li> <li> <p>Create the application in OKD. This command tells OKD to build and deploy your application from your Git repository using the <code>Dockerfile</code>.     <pre><code># Choose a name for your application, e.g., \"my-rps-game\"\noc new-app . \\\n--name=&lt;your-app-name&gt; \\\n--source-secret=&lt;your-secret-name&gt; \\\n--strategy=docker \\\n--labels=app=&lt;your-app-name&gt;\n</code></pre></p> <ul> <li> <p><code>--name</code>: This will be the name of your application, service, and route in OKD.</p> </li> <li> <p><code>--source-secret</code>: This must match the secret name you created in the previous step.</p> </li> <li> <p><code>--labels=app=&lt;your-app-name&gt;</code>: This adds a label to all the resources created (<code>Deployment</code>, <code>Service</code>, etc.). This is extremely useful because it allows you to manage all related components with a single command, like when you want to delete the application later.</p> </li> </ul> </li> <li> <p>Expose the service to make it accessible on the internet.     <pre><code>oc create route edge --service=&lt;your-app-name&gt;\n</code></pre>     You can get the public URL by running oc get route ."},{"location":"swe/cicd/#4-set-up-the-webhook-for-automatic-deployments","title":"4. Set up the Webhook for Automatic Deployments","text":"<p>The final step is to connect our CI pipeline to our CD platform. We'll use a webhook: after the tests pass, GitHub Actions will send a request to a special URL in OKD, triggering a new deployment.</p> <ol> <li>Get the webhook URL from your OKD build configuration:     <pre><code>oc describe bc/&lt;your-app-name&gt; | grep -C 1 generic\n</code></pre></li> <li>In your GitHub repository, go to Settings &gt; Secrets and variables &gt; Actions.</li> <li>Click New repository secret.</li> <li>Name the secret <code>WEBHOOK_URL</code> and paste the full webhook URL from the previous step.</li> <li>The <code>curl</code> command in our <code>test.yml</code> workflow file will now automatically trigger a new deployment on OKD every time the tests successfully pass on the <code>main</code> branch!</li> </ol> <p>And that's it! You now have a fully automated CI/CD pipeline. Every time you push a change, it will be tested, and if successful, deployed directly to production.</p>"},{"location":"swe/fastapitutorial/","title":"FastAPI and Pydantic Tutorial","text":"<p>FastAPI is a modern, fast (high-performance), standards-first web framework for Python. FastAPI helps you both specify and build RESTful HTTP APIs quickly.</p> <p>Pydantic is a library used by FastAPI for data modeling and validation. It is how we will specify the schemas for request and response body data. It enforces type hints at runtime and yields user-friendly errors.</p>"},{"location":"swe/fastapitutorial/#part-1-starting-a-fastapi-and-pydantic-project","title":"Part 1. Starting a FastAPI and Pydantic Project","text":"<p>Before diving in, make sure you've reviewed Getting Started. We are going to be following the same steps outlined there with a few tweaks to the dev container and requirements.</p>"},{"location":"swe/fastapitutorial/#step-1-setting-up-the-development-container","title":"Step 1. Setting up the Development Container","text":"<p>After following the initial steps on creating a new project, in the devcontainer, we want to use the following template:</p> <pre><code>{\n    \"image\": \"mcr.microsoft.com/vscode/devcontainers/python:3.13\",\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"ms-python.python\",\n                \"ms-python.black-formatter\"\n            ],\n            \"settings\": {\n                \"[python]\": {\n                    \"editor.defaultFormatter\": \"ms-python.black-formatter\"\n                },\n                \"python.formatting.blackArgs\": [\n                    \"--line-length\",\n                    \"120\"\n                ],\n                \"editor.formatOnSave\": true,\n                \"python.linting.enabled\": true,\n                \"python.linting.pylintEnabled\": true,\n                \"python.analysis.typeCheckingMode\": \"basic\"\n            }\n        }\n    },\n    \"postCreateCommand\": \"pip install -r requirements.txt\"\n}\n</code></pre> Explanation of each field in this updated container <ul> <li> <p>image: Uses a specific Python 3.13 development container from Microsoft\u2019s registry. This ensures your whole team is running the same Python version.  </p> </li> <li> <p>customizations: Configures VS Code inside the container.  </p> <ul> <li> <p>extensions:  </p> <ul> <li><code>ms-python.python</code>: The official Python extension, adding linting, IntelliSense, debugging, etc.  </li> <li><code>ms-python.black-formatter</code>: Integrates the Black code formatter directly into VS Code.  </li> </ul> </li> <li> <p>settings:  </p> <ul> <li><code>[python].editor.defaultFormatter</code>: Ensures Python files use Black for formatting.  </li> <li><code>python.formatting.blackArgs</code>: Sets Black\u2019s line length limit to 120 characters (instead of the default 88).  </li> <li><code>editor.formatOnSave</code>: Automatically formats files on save, enforcing consistent style.  </li> <li><code>python.linting.enabled</code>: Enables linting so you catch errors as you type.  </li> <li><code>python.linting.pylintEnabled</code>: Uses Pylint as the linter.  </li> <li><code>python.analysis.typeCheckingMode</code>: Enables basic type checking (catches simple type mismatches).  </li> </ul> </li> </ul> </li> <li> <p>postCreateCommand: After the container is first built, this runs <code>pip install -r requirements.txt</code> so dependencies are available immediately.  </p> </li> </ul> What is Black? <p>Black is a popular Python code formatter. - It rewrites code to follow a consistent style (an \"opinionated\" formatter). - This eliminates arguments about spaces, commas, or line breaks, making all code look uniform. - The container sets Black\u2019s line length to 120 characters (instead of the default 88). - It\u2019s configured to run automatically on save in VS Code.</p> <p>Example:  </p> <pre><code># Before Black\ndef add(a,b): return a+b\n\n# After Black\ndef add(a, b):\n    return a + b\n</code></pre> What is Pylint? <p>Pylint is a Python linter \u2014 a tool that analyzes your code for errors, bugs, and style issues. - It checks for things like unused variables, undefined names, and poor practices. - Pylint also enforces Python\u2019s PEP 8 style guide, helping ensure readability. - Unlike Black (which automatically changes code), Pylint only reports issues and gives you suggestions.  </p> <p>Example output:  </p> <pre><code>myscript.py:1:0: C0114: Missing module docstring (missing-module-docstring)\nmyscript.py:3:4: C0103: Variable name \"xYz\" doesn't conform to snake_case naming style (invalid-name)\n</code></pre> <p>In this container, linting is enabled by default so that mistakes are caught as you type.  </p>"},{"location":"swe/fastapitutorial/#step-2-updating-requirementstxt","title":"Step 2. Updating <code>requirements.txt</code>","text":"<p>In addition to setting up the container, we need to update the <code>requirements.txt</code> file so our project installs the correct dependencies.</p> <p>Add the following lines to your <code>requirements.txt</code> file at the root of your project:</p> <pre><code>fastapi[standard]~=0.115.7\nblack~=24.10.0\npylint~=3.3.4\n</code></pre> Explanation: <ul> <li> <p>fastapi[standard]~=0.115.7   Installs FastAPI along with its standard extras (like <code>uvicorn</code> for running the server).   The <code>~=</code> means \u201ccompatible release\u201d \u2014 so it allows patch-level updates (e.g., <code>0.115.8</code>), but not breaking upgrades.  </p> </li> <li> <p>black~=24.10.0   Ensures that the Black formatter is available inside the container.   Even though the VS Code extension runs formatting, the CLI tool is needed for automation and consistency.  </p> </li> <li> <p>pylint~=3.3.4   Installs Pylint so the linter runs inside the container.   This ensures that linting works consistently across environments, even outside VS Code.</p> </li> </ul>"},{"location":"swe/fastapitutorial/#part-2-defining-a-route","title":"Part 2. Defining a Route","text":"<p>Create a main.py in the root directory of your project. This is where you will define your routes. In FastAPI, routes define the endpoints of your API \u2014 the URLs that clients can send requests to. A route specifies both:</p> <ul> <li>The HTTP method (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc.)  </li> <li>The path (e.g., <code>/</code>, <code>/users</code>, <code>/items/42</code>)  </li> </ul> <p>Here\u2019s a simple example in <code>main.py</code>:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root() -&gt; str:\n    return \"Hello, world!\"\n</code></pre> Breaking down the example <ul> <li> <p><code>app = FastAPI()</code>     Creates a FastAPI application instance. All routes are registered to this <code>app</code>.  </p> </li> <li> <p><code>@app.get(\"/\")</code>     This is a decorator that registers the function below it as the handler for <code>GET</code> requests sent to the <code>/</code> path (the root URL).  </p> <ul> <li><code>get</code> \u2192 the HTTP method  </li> <li><code>\"/\"</code> \u2192 the path Together, this means: \u201cWhen a client sends a GET request to <code>/</code>, run the following function.\u201d </li> </ul> </li> <li> <p><code>def read_root() -&gt; str:</code>     A standard Python function that is called when the route is hit.  </p> <ul> <li>The function name (<code>read_root</code>) is arbitrary, but should describe what the route does.  </li> <li>The return type annotation (<code>-&gt; str</code>) is optional, but clarifies that this function returns a string.  </li> </ul> </li> <li> <p><code>return \"Hello, world!\"</code>     The function\u2019s return value becomes the HTTP response body.  </p> <ul> <li>If you return a string, FastAPI automatically wraps it into a valid HTTP response.  </li> <li>For more complex data, you typically return a dictionary or Pydantic model, which FastAPI will automatically convert to JSON.  </li> </ul> </li> </ul> <p>Key Idea</p> <p>Every route in FastAPI follows this same pattern:</p> <pre><code>@app.&lt;method&gt;(\"&lt;path&gt;\")\ndef &lt;function_name&gt;(...):\n    return &lt;response&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;method&gt;</code> is one of <code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, or <code>delete</code>.</li> <li><code>&lt;path&gt;</code> is the URL endpoint.</li> <li><code>&lt;function_name&gt;</code> is any descriptive name you choose.</li> <li><code>&lt;response&gt;</code> is the data you want to send back to the client.</li> </ul>"},{"location":"swe/fastapitutorial/#part-3-running-the-development-server","title":"Part 3. Running the Development Server","text":"<p>To run your FastAPI app in development, navigate to your project folder in the terminal and run: <pre><code>fastapi run main.py --reload\n</code></pre></p> What this does <ul> <li> <p>Runs at http://127.0.0.1:8000 By default, FastAPI\u2019s dev server listens on this address and port. Note: If another server (like your MkDocs dev server) is using port 8000, check the Ports tab in VS Code to see what host port this container\u2019s 8000 is mapped to.  </p> </li> <li> <p><code>--reload</code> argument Tells FastAPI to watch your source files. When changes are detected, the server automatically reloads. This saves you from stopping and restarting the server each time you make edits.  </p> </li> <li> <p>Uvicorn Under the hood, FastAPI runs on Uvicorn, an ASGI server that handles low-level HTTP requests. You usually don\u2019t need to worry about it, but if you see references to Uvicorn in docs or logs, just know it\u2019s the HTTP layer beneath FastAPI.  </p> </li> </ul> <p>Whenever a request is sent to <code>GET /</code>, FastAPI calls the <code>read_root()</code> function you defined.</p>"},{"location":"swe/fastapitutorial/#part-4-using-pydantic-models-to-define-schemas","title":"Part 4. Using Pydantic Models to Define Schemas","text":"<p>In FastAPI, Pydantic models let you define the structure of your data in Python. They serve two main purposes:</p> <ol> <li> <p>Server-side Python objects \u2013 You can use the models throughout your code as typed classes.</p> </li> <li> <p>API schema validation \u2013 FastAPI automatically generates JSON schemas from your models for request and response validation.</p> </li> </ol>"},{"location":"swe/fastapitutorial/#how-to-define-a-pydantic-model","title":"How to Define a Pydantic Model","text":"<ol> <li> <p>Import <code>BaseModel</code> from <code>pydantic</code>.</p> </li> <li> <p>Create a Python class that inherits from <code>BaseModel</code>.</p> </li> <li> <p>Add attributes with type annotations to define the data structure.</p> </li> </ol> <p>Example of creating a BaseModel:     <pre><code>from pydantic import BaseModel\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    description: str | None = None\n</code></pre></p> Explanation <ul> <li> <p><code>id</code> and <code>name</code> are required fields.</p> </li> <li> <p><code>description</code> is optional (None by default).</p> </li> <li> <p>The class itself acts as both a Python object and a schema definition.</p> </li> </ul>"},{"location":"swe/fastapitutorial/#using-models-in-routes","title":"Using Models in Routes","text":"<p>You can use Pydantic models for:</p> <ul> <li> <p>Request bodies \u2013 FastAPI will validate incoming JSON and automatically convert it into a model instance.</p> </li> <li> <p>Response bodies \u2013 FastAPI will convert model instances to JSON for the client.</p> </li> </ul> <p>Example of returning a list of model instances:     <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n# Example \"database\"\nitems_db: dict[int, Item] = {}\n\n@app.get(\"/items\")\ndef list_items() -&gt; list[Item]:\n    return list(items_db.values())\n</code></pre></p> Explanation <ul> <li> <p>items_db stores Python objects that are instances of Item.</p> </li> <li> <p>list_items returns a list of Pydantic models. FastAPI automatically converts these to JSON.</p> </li> <li> <p>The function\u2019s return type (list[Item]) specifies the expected response schema.</p> </li> </ul> Example All Together <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Post(BaseModel):\n    id: int\n    content: str\n\n# Prepopulate dictionary of posts\nposts_db = {\n    1: Post(id=1, content=\"Hello FastAPI!\"),\n    2: Post(id=2, content=\"Writing my second post!\")\n}\n\n@app.get(\"/\")\ndef read_root() -&gt; str:\n    return \"Hello, world!\"\n\n@app.get(\"/about\")\ndef read_about() -&gt; str:\n    return \"This is a simple HTTP API.\"\n\n@app.get(\"/posts\")\ndef list_posts() -&gt; list[Post]:\n    return list(posts_db.values())\n</code></pre> <p>How This Works</p> <ul> <li>We store two example posts in a global dictionary, <code>posts_db</code>, keyed by their ID.</li> <li>The route <code>GET /posts</code> returns <code>list(posts_db.values())</code>, which effectively returns all posts as a list.</li> <li>Notice how each value in <code>posts_db</code> is already an instance of <code>Post</code>. When FastAPI sees these objects, it converts them to JSON automatically.</li> </ul> <p>Notice the return type of the <code>list_posts</code> function is a <code>list</code> of <code>Post</code> objects. This is specifying the response body schema. Try visiting this route in your browser to confirm it is working. If you do not see well formatted JSON that is easy to read, try going back to the previous part of this reading and installing a JSON Viewer plugin in your web browser.</p> <p>Key Points to Remember</p> <ul> <li> <p>Validation happens automatically \u2013 If the data doesn\u2019t match the model\u2019s types, FastAPI returns a clear error response.</p> </li> <li> <p>Optional fields can be specified with <code>field: type | None = default</code>.</p> </li> <li> <p>Nested models are allowed \u2013 a model attribute can itself be another Pydantic model.</p> </li> <li> <p>Type hints are crucial \u2013 FastAPI relies on them for validation, documentation, and auto-completion.</p> </li> </ul> <p>This approach ensures your API responses and requests are consistent, readable, and easy to validate. You can now expand your API by defining more models for different resources or more complex nested data structures.</p>"},{"location":"swe/fastapitutorial/#part-5-adding-a-dynamic-route","title":"Part 5. Adding a Dynamic Route","text":"<p>So far, we\u2019ve only worked with static paths like <code>/</code> or <code>/items</code>. But real APIs often need dynamic paths where part of the URL is a variable. For example:</p> <ul> <li><code>/items/1</code> \u2192 fetch item with ID 1</li> <li><code>/users/alice</code> \u2192 fetch data for the user <code>\"alice\"</code></li> </ul> <pre><code>In FastAPI, this is done using path parameters.\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n# Pretend database\nitems_db = {\n    1: Item(id=1, name=\"Widget\"),\n    2: Item(id=2, name=\"Gadget\"),\n}\n\n@app.get(\"/items/{item_id}\")\ndef get_item(item_id: int) -&gt; Item:\n    if item_id in items_db:\n        return items_db[item_id]\n    raise HTTPException(status_code=404, detail=\"Item not found\")\n</code></pre>"},{"location":"swe/fastapitutorial/#how-it-works","title":"How it Works","text":"<ul> <li> <p><code>@app.get(\"/items/{item_id}\")</code></p> <ul> <li> <p>The <code>{item_id}</code> part makes the path dynamic.</p> </li> <li> <p>Whatever value is passed in the URL gets captured and passed into the function as the <code>item_id</code> parameter.</p> </li> </ul> </li> <li> <p><code>item_id: int</code></p> <ul> <li> <p>Declaring <code>item_id</code> as an <code>int</code> means FastAPI automatically validates it.</p> </li> <li> <p>If the client provides a non-integer (like <code>/items/abc</code>), FastAPI responds with a 422 Unprocessable Entity error.</p> </li> </ul> </li> <li> <p>Returning a model</p> <ul> <li> <p>If the ID exists, the function returns the corresponding <code>Item</code> (a Pydantic model).</p> </li> <li> <p>FastAPI automatically converts it into JSON.</p> </li> </ul> </li> <li> <p>Raising an exception</p> <ul> <li> <p>If the ID is not found, the function raises an <code>HTTPException</code>.</p> </li> <li> <p>This is how you return error responses in FastAPI.</p> </li> </ul> </li> </ul> Try It Out <p>\u2705 Happy path: Visit <code>/items/1</code> or <code>/items/2</code>. You\u2019ll get a valid JSON response with item data.</p> <p>\u274c Not found: Visit <code>/items/99</code>. You\u2019ll get a 404 Not Found response, because the item isn\u2019t in our database.</p> <p>\u26a0\ufe0f Invalid type: Visit <code>/items/abc</code>. You\u2019ll get a 422 Unprocessable Entity response, because <code>\"abc\"</code> is not an integer.</p> <p>Why This Matters</p> <p>Dynamic routes let you build APIs that interact with specific resources.</p> <ul> <li> <p><code>/users/{user_id}</code> \u2192 fetch a specific user</p> </li> <li> <p><code>/orders/{order_id}</code> \u2192 fetch details for a given order</p> </li> <li> <p><code>/products/{sku}</code> \u2192 fetch a product by stock-keeping unit</p> </li> </ul> <p>FastAPI handles both validation and error reporting automatically, reducing boilerplate code.   x</p> <p>Automatic API Documentation</p> <p>One of FastAPI\u2019s biggest benefits is that it automatically generates interactive API documentation.  </p> <ul> <li> <p>Visit <code>/docs</code> \u2192 Opens a web interface (built on OpenAPI) where you can:</p> <ul> <li>See all your endpoints.</li> <li>Try them out directly in your browser.</li> <li>View sample requests and responses.  </li> </ul> </li> <li> <p>Visit <code>/openapi.json</code> \u2192 Shows the raw JSON specification for your API, which can be used by tools or code generators.  </p> </li> </ul> <p>Because FastAPI uses Pydantic models for request and response bodies, the documentation automatically includes: - Field types - Validation rules - Possible error states  </p> <p>\u2705 This makes <code>/docs</code> your go-to place to explore, test, and understand your API while developing.</p>"},{"location":"swe/fastapitutorial/#part-6-adding-a-post-route","title":"Part 6. Adding a POST Route","text":"<p>Make your API writable by letting clients create new resources. Below is an example that uses the same <code>Item</code> model and <code>items_db</code> used earlier so it fits with the existing examples.</p> <pre><code>from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    description: str | None = None\n\n# Example in-memory \"database\" (already used elsewhere in this tutorial)\nitems_db = {\n    1: Item(id=1, name=\"Widget\"),\n    2: Item(id=2, name=\"Gadget\"),\n}\n\n@app.post(\"/items\", status_code=status.HTTP_201_CREATED)\ndef create_item(item: Item):\n    if item.id in items_db:\n        raise HTTPException(status_code=400, detail=\"Item with this ID already exists\")\n    items_db[item.id] = item\n    return item\n</code></pre> Request body &amp; validation <p>When a client sends JSON to <code>POST /items</code>, FastAPI automatically:</p> <ul> <li> <p>Parses the request body into a <code>Item</code> instance (because the handler declares <code>item: Item</code>).</p> </li> <li> <p>Runs validation using Pydantic (type checks, required fields, optional fields).</p> </li> </ul> <p>If validation fails, FastAPI returns a 422 Unprocessable Entity response with details about the problem.</p> Status code <p>The decorator parameter <code>status_code=status.HTTP_201_CREATED</code> tells FastAPI to return a 201 Created status on success. This is the conventional response for resource creation. If you instead want to replace an existing resource, use <code>PUT</code> (idempotent) or return a different status code as appropriate.</p> Try it in <code>/docs</code> <ol> <li>Open <code>/docs</code>, find POST /items and click Try it out.  </li> <li>Provide a sample JSON body, for example: <pre><code>{\n  \"id\": 3,\n  \"name\": \"New Widget\",\n  \"description\": \"A shiny new widget\"\n}\n</code></pre></li> <li>Click Execute and inspect the response (should be 201 and return the created item).  </li> <li>Verify by calling GET /items/{item_id} (or visiting <code>/items/3</code>) to see the new resource.</li> </ol> In-memory storage is ephemeral <p>This example uses a Python dictionary (<code>items_db</code>) stored in module memory. It is not persistent:</p> <ul> <li> <p>When the server restarts or reloads, <code>items_db</code> resets to its initial contents.</p> </li> <li> <p>For real applications, use a persistent database (Postgres, SQLite, etc.) so data survives restarts.</p> </li> </ul> Handling duplicates / alternatives <ul> <li> <p>This example returns 400 Bad Request if an <code>id</code> already exists. Another pattern is:</p> <ul> <li> <p>Use <code>PUT /items/{id}</code> to create-or-replace a resource (idempotent).</p> </li> <li> <p>Use server-assigned IDs (client posts without <code>id</code>) and return the new ID in the response.</p> </li> </ul> </li> </ul>"},{"location":"swe/fastapitutorial/#part-7-updating-and-deleting-items","title":"Part 7. Updating and Deleting Items","text":"<p>To complete our CRUD operations (Create, Retrieve, Update, Delete), we need to add routes for updating an existing item and deleting an item.  </p> <p>Here\u2019s an example using the same <code>Item</code> model and <code>items_db</code> dictionary introduced earlier:</p> <pre><code>from fastapi import FastAPI, HTTPException, status\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    description: str | None = None\n\nitems_db = {\n    1: Item(id=1, name=\"Widget\"),\n    2: Item(id=2, name=\"Gadget\"),\n}\n\n@app.put(\"/items/{item_id}\")\ndef update_item(item_id: int, updated_item: Item) -&gt; Item:\n    if item_id not in items_db:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    items_db[item_id] = updated_item\n    return updated_item\n\n@app.delete(\"/items/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_item(item_id: int) -&gt; None:\n    if item_id not in items_db:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    del items_db[item_id]\n    return None  # 204 = No Content\n</code></pre> PUT: Update a Resource <ul> <li><code>PUT /items/{item_id}</code> replaces the resource at that URL with the new data sent in the request body.  </li> <li>If the item doesn\u2019t exist, return 404 Not Found.  </li> <li>The response includes the updated resource, so the client can confirm the change.  </li> </ul> DELETE: Remove a Resource <ul> <li><code>DELETE /items/{item_id}</code> removes the resource with that ID from the dictionary.  </li> <li>A successful delete returns 204 No Content, which means the action succeeded but there is nothing to return.  </li> <li>If the item doesn\u2019t exist, return 404 Not Found.  </li> </ul> Trying it in <code>/docs</code> <p>With your dev server running:</p> <ol> <li> <p>Go to <code>/docs</code> and expand the PUT /items/{item_id} section.  </p> <p>Enter an existing ID (e.g., <code>1</code>) and provide a body like:  </p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Updated Widget\",\n    \"description\": \"Improved version\"\n}\n</code></pre> <p>Execute, and check the response to see the updated item.  </p> </li> <li> <p>Confirm with GET /items/{item_id} that the item was updated.  </p> </li> <li> <p>Expand DELETE /items/{item_id} and provide the same ID.    Execute, and you\u2019ll get a 204 response.    Use GET /items/{item_id} again to confirm it was deleted (should return 404).  </p> </li> </ol> CRUD recap <p>With <code>POST</code>, <code>GET</code>, <code>PUT</code>, and <code>DELETE</code>, you now have the complete set of core HTTP methods for managing resources in your FastAPI app.</p>"},{"location":"swe/fastapivalidation/","title":"Parameter Validation with FastAPI","text":"<p>FastAPI leverages Pydantic and standard Python type hints to automatically perform data validation. While simple type hints (like <code>int</code>, <code>str</code>, or <code>float</code>) are sufficient for basic validation and conversion, you often need to enforce additional constraints on your URL parameters.</p> <p>FastAPI provides the <code>Path</code> and <code>Query</code> functions to declare extra metadata and apply detailed validation rules to path and query parameters, respectively.</p>"},{"location":"swe/fastapivalidation/#1-dynamic-path-validation-numeric","title":"1. Dynamic Path Validation (Numeric)","text":"<p>Path parameters are required by definition, as they are part of the URL itself. You typically use path validation to ensure a parameter is a valid number within a specific range.</p> <p>To add validation to a path parameter, you must import and use the <code>Path</code> function, often inside Python's <code>Annotated</code> type hint.</p>"},{"location":"swe/fastapivalidation/#applying-numeric-constraints","title":"Applying Numeric Constraints","text":"<p>You can use the following arguments within <code>Path()</code> to set up numeric validation:</p> Argument Description Example Constraint <code>gt</code> Greater Than <code>gt=10</code> (must be &gt; 10) <code>ge</code> Greater than or Equal <code>ge=10</code> (must be \u2265 10) <code>lt</code> Less Than <code>lt=100</code> (must be &lt; 100) <code>le</code> Less than or Equal <code>le=100</code> (must be \u2264 100) <pre><code>from typing import Annotated\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\ndef read_items(\n    # item_id must be an integer, greater than 0, and less than or equal to 100\n    item_id: Annotated[int, Path(title=\"The ID of the item\", gt=0, le=100)]\n):\n    \"\"\"\n    Retrieves an item by its ID, enforcing numeric constraints.\n    If item_id is not a number, or outside the range 1-100, a 422 error is returned.\n    \"\"\"\n    return {\"item_id\": item_id}\n</code></pre> <p>Automatic Error Handling</p> <p>If the client sends a value that violates these constraints (e.g., <code>/items/101</code> when <code>le=100</code>), FastAPI automatically returns a 422 Unprocessable Entity error with clear details about which constraint was broken.</p>"},{"location":"swe/fastapivalidation/#2-query-parameter-validation-string","title":"2. Query Parameter Validation (String)","text":"<p>Query parameters are defined as function parameters that are not part of the path. They are typically optional and are used for filtering or sorting.</p> <p>To add validation to a query parameter, you must import and use the <code>Query</code> function, often within <code>Annotated</code>.</p>"},{"location":"swe/fastapivalidation/#applying-string-constraints","title":"Applying String Constraints","text":"<p>You can use the following arguments within <code>Query()</code> to set up string validation:</p> Argument Description Example Constraint <code>min_length</code> Minimum required string length <code>min_length=3</code> <code>max_length</code> Maximum allowed string length <code>max_length=50</code> <code>regex</code> Regular expression pattern the string must match <code>regex=\"^search.*\"</code> <code>alias</code> Specify an alternative name for the parameter in the URL <code>alias=\"s-query\"</code> <pre><code>from typing import Annotated, Union\nfrom fastapi import FastAPI, Query\n\napp = FastAPI()\n\n@app.get(\"/search/\")\ndef search_items(\n    # q is optional (Union[str, None]), has a maximum length of 50, and must match a pattern\n    q: Annotated[Union[str, None], Query(max_length=50, regex=\"^search.*\", alias=\"s-query\")] = None,\n    # limit must be an integer, greater than 0, and is optional (default=25)\n    limit: Annotated[int, Query(gt=0)] = 25\n):\n    \"\"\"\n    Search endpoint with validation on the query string (s-query) and limit.\n    \"\"\"\n    results = {\"q\": q, \"limit\": limit}\n    return results\n</code></pre> <p>Understanding str | None = None</p> <p>This common syntax is how you define an optional parameter that also has a type constraint:</p> <ol> <li>Type Hint (<code>str | None</code>): This uses the modern Union Operator (<code>|</code>) in Python 3.10+. It declares that the variable <code>q</code> can hold either a string value (if the client provides it) or the special value <code>None</code> (if the client omits it).</li> <li>Default Value (<code>= None</code>): Setting the default to <code>None</code> explicitly tells FastAPI that this parameter is optional. If you did not set a default value, FastAPI would treat <code>q</code> as required, even if the type hint included <code>| None</code>.</li> </ol> How <code>regex</code> and <code>alias</code> work together <p>When you define a parameter using both an <code>alias</code> and a <code>regex</code>, the following happens:</p> <ol> <li><code>alias=\"s-query\"</code>: This tells FastAPI that the URL parameter a client sends must be named <code>s-query</code> (e.g., <code>GET /search/?s-query=search_term</code>) instead of using the function's internal name (<code>q</code>).</li> <li><code>regex=\"^search.*\"</code>: This is a powerful validation rule. It ensures that the value provided for <code>s-query</code> must start with the exact string <code>search</code>.<ul> <li>\u2705 Valid: <code>s-query=search_term</code></li> <li>\u274c Invalid: <code>s-query=find_term</code></li> </ul> </li> </ol>"},{"location":"swe/fastapivalidation/#code-example","title":"Code Example","text":"<p>In this function signature, <code>q</code> is the internal Python variable, but the client must use <code>s-query</code>:</p> <pre><code>from typing import Annotated, Union\nfrom fastapi import FastAPI, Query\n\n@app.get(\"/search/\")\ndef search_items(\n    # The internal variable name is 'q'\n    q: Annotated[Union[str, None], Query(alias=\"s-query\", regex=\"^search.*\")] = None\n):\n    # ... logic\n    return {\"query\": q}\n</code></pre>"},{"location":"swe/fastapivalidation/#client-interaction","title":"Client Interaction","text":"URL Request Result <code>/search/?s-query=search_widgets</code> Success (200 OK) <code>/search/?s-query=find_widgets</code> Failure (422 Unprocessable Entity) <code>/search/?q=search_widgets</code> Success, but 'q' is treated as a separate, unvalidated parameter (because the alias was set)."},{"location":"swe/fastapivalidation/#required-vs-optional-query-parameters","title":"Required vs. Optional Query Parameters","text":"<p>The required status of a query parameter is determined by its default value in the function signature:</p> <ul> <li>Optional: If you set the default value to <code>None</code> or provide any default value (e.g., <code>limit=25</code>), the parameter is optional.</li> <li>Required: If you do not set a default value, the parameter is required. To enforce requirements while still using <code>Query</code> for validation/metadata, you can use the literal <code>...</code> (Ellipsis) as the default value.</li> </ul> <p>Make a Parameter Required</p> <p>If you want a query parameter to be required without providing a specific default value, use <code>...</code> (Ellipsis) as the default.</p> <p>Example: <pre><code>from fastapi import Query\n# ...\n# This query parameter is REQUIRED, has min_length 5, and no default value\nrequired_id: str = Query(min_length=5, default=...)\n</code></pre></p> <p>This use of <code>Path</code> and <code>Query</code> ensures that parameter validation is automatically handled and documented in your interactive <code>/docs</code> interface.</p>"},{"location":"swe/gettingstarted/","title":"Getting Started","text":""},{"location":"swe/gettingstarted/#starting-a-project","title":"Starting a Project","text":"<p>This section will help you start/initialize a project. The following is covered:</p> <ul> <li>Set up a basic Python development container in VS Code.</li> <li>Initialize and configure a GitHub repository for a static site.</li> <li>Deploy your site to GitHub Pages with GitHub Actions for CI/CD.</li> </ul>"},{"location":"swe/gettingstarted/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following:</p> <ul> <li>A GitHub account: If you don\u2019t have one yet, sign up at GitHub.</li> <li>Git installed: Install Git if you don\u2019t already have it.</li> <li>Visual Studio Code (VS Code): Download and install it from here.</li> <li>Docker: Required to run the dev container. Get Docker here.</li> </ul>"},{"location":"swe/gettingstarted/#part-1-project-setup-creating-the-repository","title":"Part 1. Project Setup: Creating the Repository","text":""},{"location":"swe/gettingstarted/#step-1-create-a-local-directory-and-initialize-git","title":"Step 1. Create a Local Directory and Initialize Git","text":"<p>(A) Open your terminal or command prompt.  </p> <p>(B) Create a new directory for your project and change into it:</p> Note <p>You can do this in the terminal using the following commands:</p> <pre><code>mkdir project-name\ncd project-name\n</code></pre> <p>Make sure you <code>cd</code> into the folder/path you want to make the project first.</p> <p>You can also just simply make this either using your file manager or in VS Code.</p> <p>(C) Initalize a new Git Repository:</p> <pre><code>git init\n</code></pre> <p>This creates a .git directory and starts tracking your project with Git.</p>"},{"location":"swe/gettingstarted/#step-2-create-a-remote-repository-on-github","title":"Step 2. Create a Remote Repository on GitHub","text":"<ol> <li>Log in to your GitHub account and navigate to the Create a New Repository page.  </li> <li>Fill in the details as follows:  </li> <li>Repository Name: <code>project-name-on-github</code> </li> <li>Description: \"project description\"  </li> <li>Visibility: Public  </li> <li>Do not initialize the repository with a README, <code>.gitignore</code>, or license.  </li> <li>Click Create Repository.  </li> </ol>"},{"location":"swe/gettingstarted/#step-3-link-your-local-repository-to-github","title":"Step 3. Link Your Local Repository to GitHub","text":"<ol> <li> <p>Add the GitHub repository as a remote:  </p> <pre><code>git remote add origin https://github.com/&lt;your-username&gt;/project-name-on-github.git\n</code></pre> <p>Note</p> <p>Replace <code>&lt;your-username&gt;</code> with your actual GitHub username.  </p> </li> <li> <p>Check your default branch name with:  </p> <pre><code>git branch\n</code></pre> <p>If it\u2019s not <code>main</code>, rename it:  </p> <pre><code>git branch -M main\n</code></pre> <p>Info</p> <p>Older versions of Git use <code>master</code> as the default branch name, but the current standard is <code>main</code>.  </p> </li> <li> <p>Push your local commits to GitHub:  </p> <pre><code>git push --set-upstream origin main\n</code></pre> Understanding the <code>--set-upstream</code> flag <p>The command <code>git push --set-upstream origin main</code> pushes your local <code>main</code> branch to the remote <code>origin</code>. The <code>--set-upstream</code> (or <code>-u</code>) flag links your local <code>main</code> branch to the remote one, so in the future you can simply run:  </p> <pre><code>git push\ngit pull\n</code></pre> <p>without specifying the branch each time.  </p> </li> <li> <p>Back in your web browser, refresh your GitHub repository.  </p> </li> <li>You should now see your initial commit on GitHub.  </li> <li> <p>To double-check locally, run:  </p> <pre><code>git log\n</code></pre> <p>The commit ID and message should match what you see on GitHub.  </p> </li> </ol>"},{"location":"swe/gettingstarted/#part-2-setting-up-the-development-environment","title":"Part 2. Setting Up the Development Environment","text":""},{"location":"swe/gettingstarted/#step-1-add-a-development-container-configuration","title":"Step 1. Add a Development Container Configuration","text":"<ol> <li>In VS Code, open your project directory. You can do this via: File &gt; Open Folder.  </li> <li>Install the Dev Containers extension for VS Code.  </li> <li> <p>Create a <code>.devcontainer</code> directory in the root of your project. Inside this \"hidden\" configuration directory, create a file called:  </p> <pre><code>.devcontainer/devcontainer.json\n</code></pre> </li> <li> <p>The <code>devcontainer.json</code> file defines the configuration for your development environment. Here\u2019s an example template:  </p> <pre><code>{\n  \"name\": \"My Project Dev Container\",\n  \"image\": \"mcr.microsoft.com/devcontainers/python:latest\",\n  \"customizations\": {\n    \"vscode\": {\n      \"settings\": {},\n      \"extensions\": [\"ms-python.python\"]\n    }\n  },\n  \"postCreateCommand\": \"pip install -r requirements.txt\"\n}\n</code></pre> Explanation of each field <ul> <li> <p>name: A descriptive name for your dev container.</p> </li> <li> <p>image: The Docker image to use (here, a Python environment). Microsoft maintains base images for many languages, or you can create your own.</p> </li> <li> <p>customizations: Add useful VS Code configurations, like installing extensions automatically for anyone using this container.</p> </li> <li> <p>postCreateCommand: Commands to run after the container is created. For example, install dependencies from requirements.txt.</p> </li> </ul> requirements.txt <p>This is a file created at the root of your project directory called <code>requirements.txt</code>. It lists the Python packages that should be installed in the container for the project to run.  </p> <p>For example, this documentation project\u2019s <code>requirements.txt</code> contains:  </p> <pre><code>mkdocs-material~=9.5\n</code></pre> </li> <li> <p>After saving the file, you can reopen your project in the dev container via the VS Code command palette: Remote-Containers: Reopen in Container.</p> </li> </ol>"},{"location":"swe/gettingstarted/#part-3-deploying-with-github-pages-or-any-static-site","title":"Part 3. Deploying with GitHub Pages (or any static site)","text":"<p>In this section, you'll set up an automated deployment process using GitHub Actions, a tool for Continuous Integration and Continuous Deployment (CI/CD). This means every time you push changes to GitHub, a series of automated steps will run to build, test, and deploy your site or project. This ensures your site is always up-to-date with your latest changes.</p>"},{"location":"swe/gettingstarted/#what-youll-do","title":"What You'll Do","text":"<ul> <li>Add a GitHub Actions workflow to define the automated deployment process.</li> <li>Push changes and observe the deployment process in action.</li> </ul>"},{"location":"swe/gettingstarted/#step-1-add-a-github-action-for-cicd","title":"Step 1. Add a GitHub Action for CI/CD","text":"<p>Create a workflow file in your repository:</p> <pre><code>mkdir -p .github/workflows\ncode .github/workflows/ci.yml\n</code></pre> <p>This file defines the steps for your CI/CD workflow.</p> <pre><code>name: Deploy Project\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: write\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.x'\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n      - name: Build and Deploy\n        run: &lt;your-deploy-command&gt;\n</code></pre> Explanation of workflow fields <p>name: This is the name of your workflow. It will appear in the GitHub Actions UI so you can easily identify it (e.g., \"Deploy Project\").</p> <p>on.push.branches: Specifies that the workflow should run whenever changes are pushed to the listed branches (here, the <code>main</code> branch). You could add more branches if needed.</p> <p>permissions.contents: Grants the workflow permission to write back to your repository. This is required if your deployment pushes to a branch like <code>gh-pages</code>.</p> <p>jobs: Defines a set of tasks that will run as part of the workflow. You can have multiple jobs if needed.</p> <p>deploy: This is the ID of the job. It can be any name, and is referenced in logs or for dependencies between jobs.</p> <p>runs-on: Specifies the environment the job runs on. <code>ubuntu-latest</code> means GitHub will provide the latest Ubuntu runner. Other options include <code>windows-latest</code> or <code>macos-latest</code>.</p> <p>steps: Lists individual steps in the job. Each step is executed in order.</p> <p>uses: Specifies a prebuilt action from GitHub Marketplace or a repository. </p> <ul> <li>Example: <code>actions/checkout@v4</code> checks out your repository so the workflow can access the code.  </li> <li>Example: <code>actions/setup-python@v5</code> sets up a Python environment on the runner.</li> </ul> <p>with: Provides parameters to an action. For example, <code>python-version: '3.x'</code> tells the Python setup action which Python version to install.</p> <p>name (inside steps): Optional name for the step. This shows in the Actions UI logs for clarity, e.g., \"Install dependencies\".</p> <p>run: Specifies a command to execute on the runner. You can write any shell command here, such as installing dependencies or deploying your site.</p>"},{"location":"swe/gettingstarted/#step-2-push-changes-and-test-the-workflow","title":"Step 2. Push Changes and Test the Workflow","text":"<ol> <li>Add and commit your workflow file and any other project changes:</li> </ol> <pre><code>git add .\ngit commit -m \"Set up CI/CD workflow\"\n</code></pre>"},{"location":"swe/gettingstarted/#understanding-your-cicd-workflow","title":"Understanding Your CI/CD Workflow","text":"<p>Once set up, the workflow will run automatically whenever you push changes to the repository:</p> <ol> <li> <p>Commit Changes Locally: Edit and save your project files, then commit the changes.</p> </li> <li> <p>Push to GitHub: The push triggers the GitHub Action workflow.</p> </li> <li> <p>Workflow Executes:</p> <ul> <li> <p>Checks out the repository</p> </li> <li> <p>Sets up the runtime environment</p> </li> <li> <p>Installs dependencies</p> </li> <li> <p>Builds the project</p> </li> <li> <p>Deploys to the specified branch or server</p> </li> </ul> </li> <li> <p>Site/Project Updated: The latest changes are now live automatically, without manual deployment.</p> </li> </ol> <p>This \"push-to-deploy\" workflow is widely used in professional development environments.</p>"},{"location":"swe/httpbasics/","title":"Key Concepts in HTTP","text":"<p>This page provides an overview of the fundamental concepts and structures of HTTP as used in modern web APIs. You will learn how URLs are broken down, the purpose and behavior of HTTP methods, how requests and responses are structured, key status codes, and the different ways input can be provided to an HTTP request. Additionally, REST principles and the roles of methods, paths, query parameters, bodies, and headers are explained to help you design and understand RESTful APIs.</p>"},{"location":"swe/httpbasics/#url-breakdown","title":"URL Breakdown","text":"<p>Example URL: <pre><code>https://api.instagram.com/users/123/posts/456/comments\n</code></pre></p> <p>Breaking down the URL: - <code>https://</code> \u2192 protocol (HTTPS = secure HTTP) - <code>api.instagram.com</code> \u2192 server domain - <code>users/123</code> \u2192 specific user (resource) - <code>posts/456</code> \u2192 specific post by that user - <code>comments</code> \u2192 collection of comments on the post  </p>"},{"location":"swe/httpbasics/#http-methods","title":"HTTP Methods","text":"Method Safety Idempotent Description GET Safe Yes Fetches information without modifying resources POST Not Safe No Creates new resources PUT Not Safe Yes Replaces an existing resource entirely PATCH Not Safe Yes Updates part of an existing resource DELETE Not Safe Yes Removes a resource Idempotency <ul> <li>Idempotent = repeating the request has the same effect as doing it once  </li> <li>Example: pressing a \"delete account\" button multiple times does not create multiple deletes (DELETE is idempotent)  </li> <li>POST is not idempotent: repeated POST requests can create multiple copies  </li> </ul>"},{"location":"swe/httpbasics/#example-uses-common-use-cases","title":"Example Uses &amp; Common Use Cases","text":""},{"location":"swe/httpbasics/#get","title":"GET","text":"<ul> <li>Examples: Viewing a user\u2019s profile page, retrieving a list of blog posts, fetching search results  </li> <li>Use Cases: Search operations, data retrieval, reading resources, querying system status  </li> </ul>"},{"location":"swe/httpbasics/#post","title":"POST","text":"<ul> <li>Examples: Adding a new comment, creating a new user account, uploading a file  </li> <li>Use Cases: Form submissions, file uploads, resource creation, data processing  </li> </ul>"},{"location":"swe/httpbasics/#put","title":"PUT","text":"<ul> <li>Examples: Updating an entire user profile, replacing a document, full configuration updates  </li> <li>Use Cases: Full resource updates, complete replacements, version management  </li> </ul>"},{"location":"swe/httpbasics/#patch","title":"PATCH","text":"<ul> <li>Examples: Updating a user\u2019s email, modifying specific fields, incremental configuration changes  </li> <li>Use Cases: Partial updates, field-specific modifications, resource property adjustments  </li> </ul>"},{"location":"swe/httpbasics/#delete","title":"DELETE","text":"<ul> <li>Examples: Removing a comment, deleting a user account, deleting a file from storage  </li> <li>Use Cases: Resource removal, cleanup operations, account deletion, content management  </li> </ul>"},{"location":"swe/httpbasics/#anatomy-of-api-communication","title":"Anatomy of API Communication","text":""},{"location":"swe/httpbasics/#request-client-server","title":"Request (Client \u2192 Server)","text":"<pre><code>POST /posts/12345/comments\nContent-Type: application/json\nAuthorization: Bearer eyJhbGc...\n\n{\n    \"comment\": \"Great photo!\",\n    \"timestamp\": \"2024-01-26T10:30:00Z\",\n    \"source\": \"mobile_app\"\n}\n</code></pre> <p>Components:</p> <ul> <li> <p>Method &amp; URL: Action and resource</p> </li> <li> <p>Headers: Metadata (content type, auth, etc.)</p> <ul> <li>Content-Type: Tells the server what format the data is in.</li> <li>Authorization: Proves who you are (usually a token).</li> </ul> </li> <li> <p>Body: Data being sent (JSON, form data, etc.)</p> </li> </ul>"},{"location":"swe/httpbasics/#response-server-client","title":"Response (Server \u2192 Client)","text":"<pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\nCache-Control: no-cache\n\n{\n    \"success\": true,\n    \"message\": \"Comment added successfully\",\n    \"comment_id\": 789,\n    \"timestamp\": \"2024-01-26T10:30:01Z\"\n}\n</code></pre> <p>Components:</p> <ul> <li> <p>Status Line: HTTP version + status code + message</p> </li> <li> <p>Headers: Metadata (content type, cache control) </p> <ul> <li>Content-Type: Format of the response (JSON).</li> <li>Cache-Control: Instructions for how clients should cache the response (or not!)</li> </ul> </li> <li> <p>Body: Actual response data (success confirmation, new IDs, etc.)</p> </li> </ul>"},{"location":"swe/httpbasics/#status-codes","title":"Status Codes","text":"<p>Informational (1xx): Connection-level information, rarely used in APIs </p> <ul> <li>101 Switching Protocols: Used when an HTTP connection is upgraded to a WebSocket  </li> </ul> <p>Success (2xx): Request successfully processed  </p> <ul> <li>200 OK: Request succeeded  </li> <li>201 Created: Resource created successfully  </li> </ul> <p>Redirection (3xx): Client must take additional action </p> <ul> <li>301 Moved Permanently: Resource permanently moved to a new URL  </li> <li>302 Found: Resource temporarily at a different URL  </li> <li>307 Temporary Redirect: Like 302, but method must not change  </li> </ul> <p>Client Error (4xx): Issue with the client request  </p> <ul> <li>400 Bad Request: Invalid syntax or parameters  </li> <li>401 Unauthorized: Authentication required or failed  </li> <li>403 Forbidden: User does not have permission  </li> <li>404 Not Found: Resource does not exist  </li> </ul> <p>Server Error (5xx): Server-side problem  </p> <ul> <li>500 Internal Server Error: Unexpected server error  </li> </ul>"},{"location":"swe/httpbasics/#providing-input-to-an-http-request","title":"Providing Input to an HTTP Request","text":"<p>HTTP requests can include input in several ways, each serving a specific purpose:  </p> <ul> <li>Methods: Define the type of action being performed (e.g., GET, POST, PUT, PATCH, DELETE).  </li> <li>Paths: Identify and route to specific resources.  </li> <li>Query Parameters: Refine or filter results without changing the resource's identity.  </li> <li>Bodies: Send structured data, typically for creating or updating resources.  </li> <li>Headers: Include metadata about the request, such as authentication or content type.</li> </ul>"},{"location":"swe/httpbasics/#rest-representational-state-transfer","title":"REST (Representational State Transfer)","text":"<p>REST is an architectural style for designing HTTP APIs that focuses on resources and stateless communication. Key points:  </p> <ul> <li>Each request from client to server contains all necessary information.  </li> <li>Clients and servers can evolve independently without breaking each other.  </li> <li>RESTful APIs use URLs to identify resources and standard HTTP methods to operate on them.  </li> </ul>"},{"location":"swe/httpbasics/#input-components","title":"Input Components","text":""},{"location":"swe/httpbasics/#methods","title":"Methods","text":"<p>Define the action you want to perform on a resource. Common methods:  </p> <ul> <li>GET: Fetch information (safe, idempotent)  </li> <li>POST: Create new resources (not safe, not idempotent)  </li> <li>PUT: Completely replace a resource (not safe, idempotent)  </li> <li>PATCH: Partially update a resource (not safe, idempotent)  </li> <li>DELETE: Remove a resource (not safe, idempotent)  </li> </ul>"},{"location":"swe/httpbasics/#paths","title":"Paths","text":"<p>Paths identify resources and define the structure of an API. Examples:  </p> <ul> <li><code>/api/users</code> \u2192 Collection of users  </li> <li><code>/api/users/42</code> \u2192 Specific user with ID 42  </li> <li><code>/api/users/42/orders</code> \u2192 Orders of user 42  </li> </ul> <p>Dynamic parts (like <code>42</code>) are variables; static parts (like <code>/users/</code>) remain constant.</p>"},{"location":"swe/httpbasics/#query-parameters","title":"Query Parameters","text":"<p>Query parameters refine requests without changing the resource identity. Examples:  </p> <ul> <li><code>/books?genre=fantasy&amp;sort=newest</code> \u2192 Filter books by genre and sort by newest  </li> <li>Common uses: filtering, sorting, pagination, searching  </li> </ul>"},{"location":"swe/httpbasics/#bodies","title":"Bodies","text":"<p>Bodies carry structured data in requests (mainly for POST/PUT).  </p> <p>Example JSON body:  </p> <pre><code>{\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <ul> <li>Defines a schema: field names, data types, and structure</li> <li>Can include complex structures like lists or nested objects</li> </ul>"},{"location":"swe/httpbasics/#headers","title":"Headers","text":"<p>Headers provide metadata about requests. Common uses:</p> <ul> <li>Authorization: e.g., <code>Authorization: Bearer abc123xyz</code></li> <li>Content-Type: e.g., <code>application/json</code></li> <li>Accept: Request a specific response format</li> </ul> <p>Headers can also support caching, security features, and content negotiation.</p>"},{"location":"swe/servicelayerdi/","title":"Service Layer and Dependency Injection","text":""},{"location":"swe/servicelayerdi/#layered-architecture-separating-concerns","title":"Layered Architecture: Separating Concerns","text":"<p>One of the most foundational patterns in software engineering is the layered architecture. This pattern organizes a system into distinct layers, where each layer only depends on the one directly below it. This creates a clean separation of concerns and helps manage complexity, especially in larger applications.</p> <p>A key rule is that lower layers should not be aware of higher layers. For example, a database layer shouldn't know about the API layer that uses it. In our FastAPI applications, we'll introduce a business logic services layer that sits between our API routes and our data persistence layer.</p>"},{"location":"swe/servicelayerdi/#what-is-the-business-logic-layer","title":"What is the \"Business Logic\" Layer?","text":"<p>This layer is often called the business logic or service layer. It contains the core rules and workflows of your application. This logic is specific to your application's domain and is kept separate from technical details like how HTTP requests are handled or how data is stored.</p> <p>The API routing layer acts as a translator, taking incoming HTTP requests, calling the appropriate methods in the service layer, and formatting the results into an HTTP response. The routes themselves should contain very little logic.</p> Why Separate Concerns? <p>Mixing all your application logic directly inside API route handlers can lead to several problems:</p> <ul> <li>Tightly Coupled Code: The code becomes hard to modify because business logic and HTTP concerns are tangled together.</li> <li>Lack of Reusability: You can't easily reuse your business logic in other places, like a command-line tool or a background worker.</li> <li>Difficult to Test: It's challenging to test your business rules in isolation from the web framework.</li> </ul> <p>By creating a separate service layer, we make our code more maintainable, reusable, and easier to test.</p>"},{"location":"swe/servicelayerdi/#example-of-layered-architecture","title":"Example of Layered Architecture","text":"<p>Let's look at a simple example of fetching a user.</p> <p>Without a Service Layer (Bad Practice)</p> <pre><code>from fastapi import FastAPI, HTTPException\nfrom models import User\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    user = database.find_user_by_id(user_id)\n    if not user:\n        # Mixing HTTP-specific errors with business logic\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\nIn this case, the route handler knows about the database and also about `HTTPException`, which is specific to FastAPI.\n</code></pre> <p>With a Service Layer (Good Practice)</p> <p>Here, the responsibilities are split. <code>services.py</code> <pre><code>from models import User\n\nclass UserDoesNotExistError(Exception):\n    pass\n\nclass UserService:\n    def get_user(self, user_id: int) -&gt; User:\n        user = database.find_user_by_id(user_id)\n        if not user:\n            # Raises a domain-specific error, not an HTTP one\n            raise UserDoesNotExistError(\"User does not exist\")\n        return user\n</code></pre> The service layer contains no FastAPI code. It raises a custom error that is specific to the application's domain.</p> <p><code>main.py</code> <pre><code>from fastapi import FastAPI, HTTPException\nfrom services import UserService, UserDoesNotExistError\nfrom models import User\n\napp = FastAPI()\nuser_service = UserService()\n\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    try:\n        return user_service.get_user(user_id)\n    except UserDoesNotExistError:\n        # The route layer translates the domain error into an HTTP error\n        raise HTTPException(status_code=404, detail=\"User not found\")\n</code></pre> The route's job is to call the service and handle any domain-specific errors, translating them into appropriate HTTP responses.</p>"},{"location":"swe/servicelayerdi/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection (DI) is a design pattern that is core to many modern frameworks like FastAPI, Spring, and Angular. The main idea is that instead of creating dependencies inside a function or class, you declare them as parameters. The framework then \"injects\" the required objects when it calls your function.</p> <p>You've already been using DI in FastAPI! When you define path parameters, query parameters, or request bodies in your route functions, FastAPI automatically provides (injects) those values for you. Now, we'll use it to inject our custom services.</p>"},{"location":"swe/servicelayerdi/#why-use-dependency-injection","title":"Why Use Dependency Injection?","text":"<p>DI makes your application:</p> <ul> <li>More Maintainable: Components are loosely coupled, so changes in one part are less likely to break another.</li> <li>Easier to Test: You can easily substitute dependencies with mock objects for unit testing.</li> <li>More Flexible: You can swap out different implementations of a service without changing the code that uses it.</li> <li>Reduces Code Duplication: Centralizes how dependencies are created and managed.</li> </ul>"},{"location":"swe/servicelayerdi/#tutorial-dependency-injection-in-fastapi","title":"Tutorial: Dependency Injection in FastAPI","text":"<p>Let's build a simple Rock, Paper, Scissors API to see DI in action.</p> <p>Goal</p> <p>We will create a <code>GameService</code> to handle the game's logic and use FastAPI's <code>Depends</code> to inject it into our API routes.</p>"},{"location":"swe/servicelayerdi/#step-1-define-the-pydantic-models","title":"Step 1: Define the Pydantic Models","text":"<p>Create a file named <code>models.py</code> for our data structures. <pre><code>from enum import Enum\nfrom datetime import datetime\nfrom typing import Annotated, TypeAlias\nfrom pydantic import BaseModel, Field\n\nclass Choice(str, Enum):\n    rock = \"rock\"\n    paper = \"paper\"\n    scissors = \"scissors\"\n\nChoiceField: TypeAlias = Annotated[\n    Choice,\n    Field(\n        description=\"Choice of rock, paper, or scissors.\",\n        examples=[\"rock\", \"paper\", \"scissors\"],\n    ),\n]\n\nclass GamePlay(BaseModel):\n    user_choice: ChoiceField\n\nclass GameResult(BaseModel):\n    timestamp: Annotated[datetime, Field(description=\"When the game was played.\")]\n    user_choice: ChoiceField\n    api_choice: ChoiceField\n    user_wins: Annotated[bool, Field(description=\"Did the user win the game?\")]\n</code></pre></p> Using <code>TypeAlias</code> <p>When you find yourself repeating complex type annotations, defining a <code>TypeAlias</code> is a great way to reduce boilerplate and improve readability.</p>"},{"location":"swe/servicelayerdi/#step-2-create-the-game-service","title":"Step 2: Create the Game Service","text":"<p>Next, create a <code>services.py</code> file. This service will contain all the business logic for the game and will have no knowledge of FastAPI. <pre><code>from datetime import datetime\nfrom random import choice as random_choice\nfrom models import GamePlay, GameResult, Choice\n\n# This is a simple in-memory store for game history.\n# It's not a real database and will reset on server restart.\n_db: list[GameResult] = []\n\nclass GameService:\n    \"\"\"Service for processing game plays.\"\"\"\n\n    def play(self, gameplay: GamePlay) -&gt; GameResult:\n        \"\"\"Play a game round.\"\"\"\n        api_choice: Choice = self._random_choice()\n        result = GameResult(\n            timestamp=datetime.now(),\n            user_choice=gameplay.user_choice,\n            api_choice=api_choice,\n            user_wins=self._does_user_win(gameplay.user_choice, api_choice),\n        )\n        _db.append(result)\n        return result\n\n    def get_results(self) -&gt; list[GameResult]:\n        \"\"\"Get all game results.\"\"\"\n        return _db\n\n    def _random_choice(self) -&gt; Choice:\n        \"\"\"Select a random choice for the API.\"\"\"\n        return random_choice(list(Choice))\n\n    def _does_user_win(self, user_choice: Choice, api_choice: Choice) -&gt; bool:\n        \"\"\"Determine if the user wins.\"\"\"\n        result: tuple[Choice, Choice] = (user_choice, api_choice)\n        winning_results: set[tuple[Choice, Choice]] = {\n            (Choice.rock, Choice.scissors),\n            (Choice.paper, Choice.rock),\n            (Choice.scissors, Choice.paper),\n        }\n        return result in winning_results\n</code></pre></p>"},{"location":"swe/servicelayerdi/#step-3-create-the-fastapi-routes-with-dependency-injection","title":"Step 3: Create the FastAPI Routes with Dependency Injection","text":"<p>Now, let's update <code>main.py</code> to use our <code>GameService</code>.</p> <p>First, let's define a <code>TypeAlias</code> for our injected service to keep the route definitions clean. <pre><code>from typing import Annotated, TypeAlias\nfrom fastapi import FastAPI, Body, Depends\nfrom models import GamePlay, GameResult\nfrom services import GameService\n\napp = FastAPI()\n\n# Create a TypeAlias for our dependency\nGameServiceDI: TypeAlias = Annotated[GameService, Depends()]\n</code></pre> Now, we can create the routes that depend on <code>GameService</code>.</p> <pre><code>@app.post(\"/play\")\ndef play(\n    user_choice: Annotated[\n        GamePlay,\n        Body(description=\"User's choice of rock, paper, or scissors.\"),\n    ],\n    game_svc: GameServiceDI,  # FastAPI injects the service here!\n) -&gt; GameResult:\n    return game_svc.play(user_choice)\n\n\n@app.get(\"/results\")\ndef get_results(game_svc: GameServiceDI) -&gt; list[GameResult]:\n    return game_svc.get_results()\n</code></pre> <p>How It Works</p> <ul> <li>We added a <code>game_svc: GameServiceDI</code> parameter to our route functions.</li> <li>The <code>Depends()</code> inside our <code>TypeAlias</code> signals to FastAPI that this is a dependency.</li> <li>Before calling the route function, FastAPI will automatically create an instance of <code>GameService</code> and pass it in as the <code>game_svc</code> argument.</li> <li>Our route handler is now clean and simple: its only job is to call the service and return the result. The creation of the service is handled by the framework.</li> </ul> <p>This is the power of dependency injection! Your route is no longer responsible for creating its dependencies, making it more focused and much easier to test. You could now easily write a unit test for the <code>play</code> function and provide a mock <code>GameService</code> to test its behavior in isolation.</p>"},{"location":"swe/testing/","title":"Introduction to Testing","text":""},{"location":"swe/testing/#why-is-testing-important","title":"Why is Testing Important?","text":"<p>Software can be fragile; a small change in one place can unexpectedly break something else. Testing provides a safety net, ensuring that your code behaves as expected, bug fixes are permanent, and new features don't reintroduce old problems.</p> <p>A good test suite doesn't just find bugs\u2014it boosts your confidence to make changes. When you have reliable tests, you can refactor code and add new features without the fear of breaking existing functionality.</p> Key Benefits of Testing <ul> <li>Verification: Tests confirm that your software meets the intended requirements.</li> <li>Preventing Regressions: Automated tests ensure that new code doesn't break existing features.</li> <li>Confidence in Changes: Good test coverage makes you more confident when modifying or adding to your codebase.</li> </ul>"},{"location":"swe/testing/#types-of-software-tests","title":"Types of Software Tests","text":"<p>Not all tests are the same. A balanced test suite will include different types of tests, each with a specific purpose. Being intentional about which tests you write is key to building a robust and maintainable application.</p> <p>Here are some of the most common types of tests:</p> <ul> <li>Unit Tests: These focus on testing individual functions or methods in isolation. They are fast and great for verifying specific pieces of logic.</li> <li>Integration Tests: These tests check that different parts of your system work together correctly, such as your API interacting with a database.</li> <li>End-to-End (E2E) Tests: E2E tests simulate a full user workflow, from the user interface to the database and back. They provide high confidence that your entire system is working as expected.</li> <li>Performance Tests: These measure how your system performs under load, helping to identify bottlenecks and other performance issues.</li> </ul> <p>For this guide, we'll focus on unit and integration tests, as they offer a great balance of speed, reliability, and value.</p>"},{"location":"swe/testing/#integration-testing-a-fastapi-backend","title":"Integration Testing a FastAPI Backend","text":"<p>Integration tests are perfect for verifying that your FastAPI application's components\u2014from routing and dependency injection to your service layer\u2014all work together.</p>"},{"location":"swe/testing/#setting-up-with-pytest","title":"Setting up with <code>pytest</code>","text":"<p>We'll use <code>pytest</code>, a popular Python testing framework. To get started, create a <code>test_main.py</code> file. <code>pytest</code> will automatically discover and run tests in files named <code>test_*.py</code> or <code>*_test.py</code>.</p> <p>Here's a basic integration test for our Rock, Paper, Scissors API:</p> <p>test_main.py</p> <pre><code>from fastapi.testclient import TestClient\nfrom main import app\n\nclient = TestClient(app)\n\ndef test_play_route_integration():\n    \"\"\"Test that the /play endpoint handles basic gameplay correctly.\"\"\"\n    response = client.post(\"/play\", json={\"user_choice\": \"rock\"})\n\n    # Check the HTTP response\n    assert response.status_code == 200\n    assert response.headers[\"content-type\"] == \"application/json\"\n\n    # Check the response body\n    data = response.json()\n    assert \"user_choice\" in data\n    assert data[\"user_choice\"] == \"rock\"\n    assert \"api_choice\" in data\n    assert \"user_wins\" in data\n    assert isinstance(data[\"user_wins\"], bool)\n</code></pre> What is <code>client = TestClient(app)</code>? <p>The <code>TestClient</code> is a special object provided by FastAPI (via Starlette) that allows you to make HTTP requests to your application directly in your tests, without needing to run a live web server.</p> <ul> <li>Why we need it: It simulates a real client (like a web browser or a mobile app) sending requests to your API. This lets you test the entire request-response cycle, including routing, dependency injection, and response formatting, all within your test suite.</li> <li>How it works: You initialize it with your FastAPI <code>app</code> instance. Then, you can use methods like <code>client.post()</code>, <code>client.get()</code>, etc., to interact with your endpoints just as a real client would.</li> </ul> Example Input and Output <ul> <li>Input: The test sends a <code>POST</code> request to the <code>/play</code> endpoint. The request body is a JSON object:     <pre><code>{\"user_choice\": \"rock\"}\n</code></pre></li> <li>Output (Example): The <code>response</code> object's <code>.json()</code> method would return a dictionary similar to this (the <code>api_choice</code> and <code>timestamp</code> will vary):     <pre><code>{\n  \"timestamp\": \"2023-10-27T10:30:00.123456\",\n  \"user_choice\": \"rock\",\n  \"api_choice\": \"paper\",\n  \"user_wins\": false\n}\n</code></pre> The test then <code>assert</code>s that this output has the correct structure and data types.</li> </ul>"},{"location":"swe/testing/#unit-testing","title":"Unit Testing","text":"<p>While integration tests are great for the big picture, unit tests let us zoom in on individual components.</p>"},{"location":"swe/testing/#unit-testing-the-gameservice","title":"Unit Testing the <code>GameService</code>","text":"<p>To test our <code>GameService</code>, we need a way to control the random choice it makes. We can use Python's <code>unittest.mock</code> to \"patch\" the <code>_random_choice</code> method and make it predictable.</p> <p>test_services.py</p> <pre><code>from unittest.mock import MagicMock\nfrom services import GameService\nfrom models import Choice, GamePlay\n\ndef create_mock_game_service(choice_to_return: Choice) -&gt; GameService:\n    \"\"\"Create a GameService with a mocked _random_choice method.\"\"\"\n    service = GameService()\n    service._random_choice = MagicMock(return_value=choice_to_return)\n    return service\n\ndef test_game_service_rock_beats_scissors():\n    # Force the service to choose \"scissors\"\n    service = create_mock_game_service(Choice.scissors)\n    result = service.play(GamePlay(user_choice=Choice.rock))\n\n    assert result.user_wins is True\n    service._random_choice.assert_called_once()\n</code></pre>"},{"location":"swe/testing/#unit-testing-a-route-function","title":"Unit Testing a Route Function","text":"<p>We can also unit test our route functions in isolation. To do this, we'll create a mock <code>GameService</code> and pass it to the route function directly.</p> <p>test_main_unit.py</p> <pre><code>from unittest.mock import MagicMock\nfrom main import play\nfrom models import GamePlay, Choice\n\ndef test_play_route_unit():\n    # Create a mock service\n    mock_service = MagicMock()\n    user_choice = GamePlay(user_choice=Choice.rock)\n\n    # Call the route function directly with the mock service\n    play(user_choice=user_choice, game_svc=mock_service)\n\n    # Verify that the route called the service's play method correctly\n    mock_service.play.assert_called_once_with(user_choice)\n</code></pre> What is <code>MagicMock</code>? <p><code>MagicMock</code> is a powerful tool from Python's <code>unittest.mock</code> library that creates flexible \"fake\" objects for testing. Think of it as a stunt double for your real objects.</p> <ul> <li>What it does: It creates an object that can pretend to be any other object. It automatically creates any methods or attributes you try to access on it.</li> <li>Why it's useful: In our unit test, we want to test the <code>play</code> route function without using a real <code>GameService</code>. <code>MagicMock</code> lets us create a fake <code>game_svc</code> that we can control completely.</li> <li>Key Feature: <code>MagicMock</code> records how it was used. After calling our route function with the mock, we can use assertion methods like <code>assert_called_once_with()</code> to verify that our route interacted with the service exactly as we expected. This proves that the route function correctly forwards its arguments to the service layer.</li> </ul> Example Input and Output <p>This test doesn't check HTTP requests or responses, but rather the interaction between the route function and the service.</p> <ul> <li>Input:<ol> <li>A <code>GamePlay</code> object: <code>GamePlay(user_choice=Choice.rock)</code></li> <li>A <code>MagicMock</code> object that stands in for our <code>GameService</code>.</li> </ol> </li> <li>Action: The test calls the <code>play</code> function directly, passing in the inputs.</li> <li>Output (Verification): The test doesn't return a value. Instead, it checks a side-effect: Was the <code>play</code> method on our mock service called exactly once, and was it called with the correct <code>GamePlay</code> object? The assertion <code>mock_service.play.assert_called_once_with(user_choice)</code> confirms this. If the route function had failed to call the service, or called it with the wrong data, the test would fail.</li> </ul>"},{"location":"swe/testing/#the-limitations-of-testing","title":"The Limitations of Testing","text":"<p>It's important to remember that testing provides confidence, not a guarantee of bug-free software. It's impossible to test every possible input and scenario. A good test suite is a pragmatic one that focuses on the most critical and complex parts of your application.</p>"}]}